#ifndef TEXTURE_H
#define TEXTURE_H

#include <memory>
#include <cassert>
#include <istream>
#include <unordered_map>
#include <functional>
#include <vector>
#include <map>
#include <string>

#include "wtypes.h"
#include "material_common.h"

namespace wcore
{

class TextureUnitInfo
{
public:
    friend class Texture;

    TextureUnitInfo(hash_t sampler_name,
                    TextureFilter filter,
                    uint32_t internal_format,
                    uint32_t format);

protected:
    hash_t sampler_name_;
    TextureFilter filter_;
    uint32_t internal_format_;
    uint32_t format_;
};

struct MaterialInfo;
class Shader;
class Texture
{
public:
    // Load texture from TextureDescriptor structure
    // Inside a MaterialDescriptor obtained from MaterialFactory
    Texture(const TextureDescriptor& descriptor);

    // Create single texture2D from stream with all default options
    // Used only for splatmap loading atm.
    Texture(std::istream& stream);

    // Create an empty texture, ideal for creating a render target for an FBO
    Texture(std::initializer_list<TextureUnitInfo> units,
            uint32_t width   = 0,
            uint32_t height  = 0,
            TextureWrap wrap_param = TextureWrap::REPEAT,
            bool lazy_mipmap = true);

    ~Texture();

    // Send sampler uniforms to shader
    void bind_sampler(const Shader& shader, TextureBlock unit) const;
    // Bind each texture unit in order
    void bind_all() const;
    // Bind texture at a given index to sampler specified by unit
    void bind(uint32_t unit=0, uint32_t index=0) const;
    // Unbind all textures
    void unbind() const;

    // Generate mipmaps for texture at given index, specifying minimum and maximum levels
    void generate_mipmaps(uint32_t index,
                          uint32_t base_level = 0,
                          uint32_t max_level = 3) const;

    // Get the number of texture units in this texture
    inline uint32_t get_num_units() const                { return n_units_; }
    // Get texture units width
    inline uint32_t get_width() const                    { return width_; }
    // Get texture units height
    inline uint32_t get_height() const                   { return height_; }
    // Get the sampler name associated to a given texture unit
    inline hash_t get_sampler_name(uint32_t index) const { return uniform_sampler_names_.at(index); }
    // Check if texture has a given special unit (like albedo, normal map...)
    inline bool has_unit(TextureUnit unit) const         { return (unit_flags_&(uint16_t)unit); }
    // Get OpenGL texture index for given unit
    inline uint32_t operator[](uint32_t index) const     { return texture_ids_[index]; }

#ifdef __DEBUG__
    // Check if texture at given index is a depth map
    inline bool is_depth(uint32_t index) const           { return is_depth_[index]; }
#endif

private:
    // Generic helper function to submit a texture unit to OpenGL
    void generate_texture_unit(unsigned int internal_format,
                               unsigned int format,
                               TextureFilter filter,
                               TextureWrap wrap_param,
                               unsigned char* data = nullptr,
                               bool lazy_mipmap = false);

private:
    uint32_t n_units_;      // Number of texture units in this texture
    uint32_t width_;        // Width of all texture units
    uint32_t height_;       // Height of all texture units
    uint16_t unit_flags_;   // Flag special units (albedo, normal, depth...) held in this texture
    uint8_t sampler_group_; // Sampler group index for splat-mapping

    std::vector<uint32_t> texture_ids_; // Hold texture IDs generated by OpenGL
    std::vector<hash_t> uniform_sampler_names_;         // Sampler names used to bind each texture block to a shader
    std::map<TextureBlock, uint32_t> block_to_sampler_; // Associate texture blocks to sampler indices

#ifdef __DEBUG__
    std::vector<bool> is_depth_; // Retain information on whether texture units contain depth info or not
#endif
};

}

#endif // TEXTURE_H
